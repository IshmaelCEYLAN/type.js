(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const i of s)if(i.type==="childList")for(const c of i.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&n(c)}).observe(document,{childList:!0,subtree:!0});function r(s){const i={};return s.integrity&&(i.integrity=s.integrity),s.referrerPolicy&&(i.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?i.credentials="include":s.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function n(s){if(s.ep)return;s.ep=!0;const i=r(s);fetch(s.href,i)}})();function re(e){return Object.prototype.toString.call(e)}const se=Symbol("break");function O(e,t){let r=0;for(const n in e)if(t(e[n],n,r++)===se)break;return e}function T(e,t){return Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)),t}function Y(e,t,r){const n={};for(const s in e){const i=e[s];s in t?(n[t[s]]=i,r!==!0&&(n[s]=i)):n[s]=i}return n}function U(e,t){return Object.defineProperty(e,Symbol.toStringTag,{value:t,writable:!1,configurable:!1,enumerable:!1}),t}function C(e,t,r){let n={};return Z(e,t,s=>{const i={};Object.assign(i,r(s)),Object.assign(i,n),n=i}),n}function _(e,t){const r=f(e);for(let n of t){let s=f(n);if(s=="Function"&&(s=n.prototype.constructor.name),r==s)return!0}return!1}function ie(e,t,r){const n=e.toString().trim(),s=/^(?!function)[\w$@]+\s*\(.*?\)\s*\{/.test(n);return Function(Object.keys(t),"return "+(s?"function ":"")+n+(r?`
//# sourceURL=`+r:"")).apply(void 0,Object.values(t))}function f(e){return re(e).replace(/\[object (.*?)\]/,"$1")}function R(e){var r,n;const t=[];for(const s of e)(n=(r=s==null?void 0:s.prototype)==null?void 0:r.constructor)!=null&&n.name?t.push(s.prototype.constructor.name):s===void 0?t.push("undefined"):s===null?t.push("null"):t.push(f(s));return t}function D(e){let t;if(Array.isArray(e)){t=[];for(const r of e)Array.isArray(r)||f(r)=="Object"?t.push(D(r)):t.push(r)}else if(f(e)=="Object"){t={};for(const r in e){const n=e[r],s=Object.getOwnPropertyDescriptor(e,r);"get"in s||"set"in s?Object.defineProperty(t,r,s):Array.isArray(n)||f(n)=="Object"?t[r]=D(n):t[r]=n}}return t}function y(e,t,r){Object.defineProperty(e,t,{value:r,writable:!0,configurable:!0,enumerable:!1})}function Z(e,t,r){do r(e);while(e=e[t]);return e}function oe(e){const t=e.trim().match(/^(?:async\s+)?(?:function\s+[\w@$]+\s*\((.*?)\)\s*{|function\s*\((.*?)\)\s*{|[\w@$]+\s*\((.*?)\)\s*{|\(?(.*?)\)?\s*=>{?)/);let r=t[1]||t[2]||t[3]||t[4];r=r?r.trim().split(","):[];for(let n=0;n<r.length;n++)r[n]=r[n].trim();return r}function S(e){if(e.length===0)return"";if(e.length===1)return e[0];if(e.length===2)return e.join(" or ");var t=e.pop();return e.join(", ")+" or "+t}function j(e){return"getPrototypeOf"in Object?Object.getPrototypeOf(e):e.__proto__}function V(e,t){return"setPrototypeOf"in Object?(Object.setPrototypeOf(e,t),t):e.__proto__=t}class ae extends Error{constructor(t,r,n){super(),this.name="MissingPropError",this.message=`The ${t.name} interface requires to define ${n.name} property on ${r.name} type.`}}class ce extends Error{constructor(t,r,n,s){super(),this.name="ReturnTypeMismatch",this.message=`${t.name} interface requires ${r.name}.${n.name} method return ${S(R(n.returnTypes)).toLowerCase()} but returned ${f(s).toLowerCase()}.`}}class he extends Error{constructor(t,r,n){super(),this.name="MissingMethodError",this.message=`The ${t.name} interface requires to define ${n.name} method on ${r.name} type. Type must therefore be declared abstract or implement the remaining methods.`}}class ue extends Error{constructor(t,r,n,s,i){super(),this.name="MissingArgumentError",this.message=`${t.name} interface requires ${r.name}.${n.name} method's ${i+1}. argument ("${s.name}") defined.`}}class de extends Error{constructor(t,r,n,s,i,c){super(),this.name="ArgumentTypeMismatch",this.message=`${t.name} interface requires ${r.name}.${n.name} method's ${i}st argument (#${s.name}) must be ${s.types.length===0?"defined":S(R(s.types)).toLowerCase()} but received ${f(c).toLowerCase()}.`}}class fe extends TypeError{constructor(t,r,n,s){super(),this.name="PropTypeMismatchError",this.message=`${t.name} interface requires ${r.name}.${n.name} property should ${S(R(n.types))} but it was ${f(s)}.`}}class le extends TypeError{constructor(t,r,n,s){super(),this.name="PropAssignTypeMismatchError",this.message=`${t.name} interface requires the ${r.name}.${n.name} property should get ${S(R(n.types))} but attempted to assign ${f(s)}.`}}function A(e,t){if(!(this instanceof A))return new A(e,t);const r=new W;t&&t(r),this.name=U(this,e),this.properties=r.properties,this.methods=r.methods,this.interfaces=[this],this.apply=function(o){n.call(this,o),c.call(this,o)},this.extends=function(...o){for(const a of o)T(a.properties,this.properties),T(a.methods,this.methods),this.interfaces.push(a);return this},this.body=function(o){return o(r),this},this.is=function(o){for(const a of this.interfaces)if(a===o)return!0;return!1},this[Symbol.hasInstance]=function(o){return o.is(this)};function n(o){O(this.properties,a=>s.call(this,o,a))}function s(o,a,l){const u=a.name,q=a.types,L=a.isRequired,x=u in o.properties,M=o.properties[u],E=q.length>0,B=o.isAbstract;if(L&&!x){if(B){o.missedProperties[u]=v=>s.call(this,v,a,o),i(this,o,a);return}throw new ae(this,o,a)}if(x&&E&&!_(M,q))throw new fe(this,o,a,M);l&&u in l.missedProperties&&delete l.missedProperties[u],E&&i(this,o,a)}function i(o,a,l){a.propertyValidators[l.name]=function(u){if(!_(u,l.types))throw new le(o,a,l,u)}}function c(o){O(this.methods,a=>h.call(this,o,a))}function h(o,a,l){const u=a.name,q=u in o.methods,L=o.isAbstract;if(!q){if(L){o.missedMethods[u]=m=>h.call(this,m,a,o);return}throw new he(this,o,a)}const x=o.methods[u],M=oe(x.toString()),E=a.returnTypes;for(const[m,w]of a.arguments.entries()){const p=M[m];if(w.isRequired&&p===void 0)throw new ue(this,o,a,w,m)}l&&e in l.missedMethods&&delete l.missedMethods[e];const B=o.methods[u];function v(...m){for(let p=0;p<$rule.arguments.length;p++){const g=$rule.arguments[p],z=g.isRequired,I=g.defaultValue;let $=m[p];g.name,$definedArgs[p];const G=g.types,ne=G.length>0;if(z&&$===void 0)if(I!==void 0)m[p]=$=I;else throw new $ArgumentTypeMismatch($iface,$type,$rule,g,p);else if(!z&&$===void 0)I!==void 0&&(m[p]=$=I);else if(ne&&!$allowed($,G))throw new $ArgumentTypeMismatch($iface,$type,$rule,g,p,$)}const w=$proxifiedMethod.apply(this,m);if($returns.length>0&&!$allowed(w,$returns))throw new $ReturnTypeMismatch($iface,$type,$rule,w);return w}v.dependencies={$type:o,$iface:this,$returns:E,$allowed:_,$rule:a,$definedArgs:M,$proxifiedMethod:B,$ReturnTypeMismatch:ce,$ArgumentTypeMismatch:de},o.methods[u]=v}}function W(){this.properties={},this.methods={}}W.prototype.property=function(e,t){return this.properties[e]=new J(e,t)};W.prototype.method=function(e,t){t(this.methods[e]=new K(e))};function J(e,t){this.name=e,this.isRequired=!1,this.types=[],t&&this.allows(t)}J.prototype.required=function(){return this.isRequired=!0,this};J.prototype.allows=function(e){return this.types=f(e)=="Array"?e:[e],this};function K(e){this.name=e,this.arguments=[],this.returnTypes=[]}K.prototype.argument=function(e,t){const r=new k(e);return this.arguments.push(r.allows(t)),r};K.prototype.returns=function(e){return this.returnTypes=f(e)=="Array"?e:e===void 0?[]:[e],this};function k(e){this.name=e,this.types=[],this.isRequired=!1,this.defaultValue=void 0}k.prototype.allows=function(e){return this.types=f(e)=="Array"?e:e===void 0?[]:[e],this};k.prototype.required=function(){return this.isRequired=!0,this};k.prototype.default=function(e){return this.defaultValue=e,this};function Q(e,t,r,n,s){const i=t.name+"::"+r,c=t.methods[r],h={...c.dependencies,...t.dependencies,parent:(o,a)=>(f(o)=="Array"&&(a=o,o=void 0),pe(e,t,r,n,s,o,a))};return ie(c,h,i)}function pe(e,t,r,n,s,i,c){if((e=e.parent)===null)throw new ReferenceError(`Because of the ${t.name} is a type that does not extend another type, the "parent" magic method shouldn't have been used in the ${r} method.`);let h=j(s);if(n===s&&(h=j(h),e=e.parent),i===void 0&&(i=r),i in h)return h[i].apply(n,c);throw j(h)===null?new ReferenceError('"parent" method was called illegally in '+e.parent.name+"."+r+" method. Within the parentless types, using parent method is ineffective."):t.parent===null?new ReferenceError(`Because of the ${t.name} is a type that does not extend another type, the "parent" magic method shouldn't have been used in the ${r} method.`):new ReferenceError("The parent method used in "+t.name+"."+r+" tried to access method "+i+", which is not defined in type "+t.parent.name+"!")}let P=[],H;function me(e){P.push(e),clearTimeout(H),H=setTimeout(be)}function ee(){clearTimeout(H)}function ge(){P.length=0}function te(e){const t=r=>r(e);try{O(e.getInheritedMissedProperties(),t),O(e.getInheritedMissedMethods(),t)}catch(r){throw ee(),r}}function ye(e){for(const[t,r]of P.entries())r===e&&(P=P.splice(t,1))}function be(){for(const e of P)te(e);ge()}function d(e){if(!(this instanceof d))return new d(e);let t=!1;this.name=U(this,e),this.constructor=(()=>{try{return{eval}.eval("( function "+encodeURIComponent(e)+"(){})")}catch{throw TypeError("In order to create a type, you need to provide a valid value as a string in the first parameter, which can also be a function name: '"+e+"'")}})(),this.parent=null,this.types=[e],this.traits=[],this.interfaces=[],this.methods={},this.properties={},this.isAbstract=!1,this.missedMethods={},this.missedProperties={},this.propertyValidators={},this.dependencies={},this.inject=function(n){return Object.assign(this.dependencies,n),this},this.abstract=function(){return this.isAbstract=!0,this},this.body=function(n){if(t)throw new SyntaxError(`${this.name}.body() method shouldn't be called more than once.`);r.call(this,n);for(const s of this.interfaces)s.apply(this);return ye(this),te(this),t=!0,this},this.extends=function(n){return this.parent=n,this.types=[...this.types,...n.types],this.traits=[...this.traits,...n.traits],Object.assign(this.dependencies,n.dependencies),this},this.implements=function(...n){return this.interfaces=n,this},this.uses=function(n,s){return r.call(this,s?Y(n.properties,s,!0):n.properties),this.traits=[...this.traits,...n.traits],Object.assign(this.dependencies,n.dependencies),this},this.create=function(){if(this.isAbstract)throw ee(),new TypeError(`${this.name} is an abstract type and cannot be instantiated.`);const n=this,s=new this.constructor;let i=V(s,{});T(D(this.getInheritedProperties()),s),this.parent?Z(this,"parent",c=>{y(i,"constructor",c.constructor);for(const h in c.methods)y(i,h,Q(this,c,h,s,i));i=V(i,{})}):y(i,"constructor",this.constructor);for(const c in this.methods)j(s)[c]=Q(this,this,c,s,s);return this.parent||(i=V(i,{})),O(this.getInheritedPropValidators(),(c,h)=>{let o=s[h];Object.defineProperty(s,h,{get:()=>o,set(a){c(a),o=a}})}),y(i,"is",c=>n.is(c,!0)),y(i,"behave",c=>n.behave(c)),y(i,Symbol.toStringTag,this.name),y(i,"constructor",d),Object.seal(i),"construct"in s&&s.construct.call(s,...arguments),s},this.getInheritedProperties=function(){const n={};return this.parent&&T(this.parent.getInheritedProperties(),n),T(this.properties,n),n},this.getInheritedMissedProperties=function(){return C(this,"parent",n=>n.missedProperties)},this.getInheritedMissedMethods=function(){return C(this,"parent",n=>n.missedMethods)},this.getInheritedPropValidators=function(){return C(this,"parent",n=>n.propertyValidators)},this.behave=function(n){return this.traits.includes(n.name)},this.is=function(n,s){if(n instanceof d)return this.types.includes(n.name);if(n instanceof A){let i=!1,c=this;e:for(;c;){for(const h of c.interfaces)if(h.is(n)){i=!0;break e}c=c.parent}return i}else if(!s){for(;n=j(n);)if(Object.is(n.constructor,this.constructor))return!0}return!1},this[Symbol.hasInstance]=function(n){return n.is(this)};function r(n){O(n,(s,i)=>this[s instanceof Function?"methods":"properties"][i]=s)}me(this)}function N(e){if(!(this instanceof N))return new N(e);this.name=U(this,e),this.traits=[this.name],this.properties={},this.dependencies={},this.uses=function(t,r){return this.body(r?Y(t.properties,r,!0):t.properties),this.traits=[...this.traits,...t.traits],Object.assign(this.dependencies,t.dependencies),this},this.body=function(t){return Object.assign(this.properties,t),this},this.inject=function(t){return Object.assign(this.dependencies,t),this},this.behave=function(t){return this.traits.includes(t.name)},this[Symbol.hasInstance]=function(t){return t.behave(this)}}