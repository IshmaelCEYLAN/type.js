(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const h of o.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&n(h)}).observe(document,{childList:!0,subtree:!0});function r(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function n(s){if(s.ep)return;s.ep=!0;const o=r(s);fetch(s.href,o)}})();const BreakSignal=Symbol("break");function tag(e){return Object.prototype.toString.call(e)}function rename(e,t,r){const n={};for(const s in e){const o=e[s];s in t?(n[t[s]]=o,r!==!0&&(n[s]=o)):n[s]=o}return n}function closured(e,t,r){const n=e.toString().trim(),s=/^(?!function)[\w$@]+\s*\(.*?\)\s*\{/.test(n);return Function(Object.keys(t),"return "+(s?"function ":"")+n+(r?`
//# sourceURL=`+r:"")).apply(void 0,Object.values(t))}function tagName(e){return tag(e).replace(/\[object (.*?)\]/,"$1")}function typeNames(e){const t=[];for(const r of e)r&&r.prototype&&r.prototype.constructor&&r.prototype.constructor.name?t.push(r.prototype.constructor.name):r===void 0?t.push("undefined"):r===null&&t.push("null");return t}function defineProp(e,t,r){Object.defineProperty(e,t,{value:r,writable:!0,configurable:!0,enumerable:!1})}function getArguments(e){const t=e.trim().match(/^(?:async\s+)?(?:function\s+[\w@$]+\s*\((.*?)\)\s*{|function\s*\((.*?)\)\s*{|[\w@$]+\s*\((.*?)\)\s*{|\(?(.*?)\)?\s*=>{?)/);let r=t[1]||t[2]||t[3]||t[4];r=r?r.trim().split(","):[];for(let n=0;n<r.length;n++)r[n]=r[n].trim();return r}function readableJoin(e){if(e.length===0)return"";if(e.length===1)return e[0];if(e.length===2)return e.join(" or ");var t=e.pop();return e.join(", ")+" or "+t}function getPrototypeOf(e){return"getPrototypeOf"in Object?Object.getPrototypeOf(e):e.__proto__}function setPrototypeOf(e,t){return"setPrototypeOf"in Object?(Object.setPrototypeOf(e,t),t):e.__proto__=t}class MissingPropError extends Error{constructor(t,r,n){super(),this.name="MissingPropError",this.message=`The ${t.name} interface requires to define ${n.name} property on ${r.name} type.`}}class ReturnTypeMismatch extends Error{constructor(t,r,n,s){super(),this.name="ReturnTypeMismatch",this.message=`${t.name} interface requires ${r.name}.${n.name} method return ${readableJoin(typeNames(n.returnTypes)).toLowerCase()} but returned ${tagName(s).toLowerCase()}.`}}class MissingMethodError extends Error{constructor(t,r,n){super(),this.name="MissingMethodError",this.message=`The ${t.name} interface requires to define ${n.name} method on ${r.name} type. Type must therefore be declared abstract or implement the remaining methods.`}}class MissingArgumentError extends Error{constructor(t,r,n,s,o){super(),this.name="MissingArgumentError",this.message=`${t.name} interface requires ${r.name}.${n.name} method's ${o+1}. argument ("${s.name}") defined.`}}class ArgumentTypeMismatch extends Error{constructor(t,r,n,s,o,h){super(),this.name="ArgumentTypeMismatch",this.iface=t,this.type=r,this.methodRule=n,this.argRule=s,this.position=o,this.value=h,this.message=s.types.length===0?this.argumentShouldPassMessage():this.argumentTypeMismatchMessage()}argumentTypeMismatchMessage(){return`${this.iface.name} interface requires ${this.type.name}.${this.methodRule.name} method's ${this.position}st argument (#${this.argRule.name}) must be ${readableJoin(typeNames(this.argRule.types)).toLowerCase()} but received ${tagName(this.value).toLowerCase()}.`}argumentShouldPassMessage(){return`The ${this.iface.name} interface prevents calling the ${this.type.name}.${this.methodRule.name} method without defining the ${this.position}th argument (#${this.argRule.name}).`}}class PropTypeMismatchError extends TypeError{constructor(t,r,n,s){super(),this.name="PropTypeMismatchError",this.message=`${t.name} interface requires the ${r.name}.${n.name} property should ${readableJoin(typeNames(n.types))} but the property is ${tagName(s)}.`}}class PropAssignTypeMismatchError extends TypeError{constructor(t,r,n,s){super(),this.name="PropAssignTypeMismatchError",this.message=`${t.name} interface requires the ${r.name}.${n.name} property should get ${readableJoin(typeNames(n.types))} but attempted to assign ${tagName(s)}.`}}function Interface(e,t){if(!(this instanceof Interface))return new Interface(e,t);const r=new Builder;t&&t(r),this.name=e,this.properties=r.properties,this.methods=r.methods,this.interfaces=[this],this.apply=function(i){n.call(this,i),h.call(this,i)},this.extends=function(...i){for(const a of i)Object.defineProperties(this.methods,Object.getOwnPropertyDescriptors(a.methods)),Object.defineProperties(this.properties,Object.getOwnPropertyDescriptors(a.properties)),this.interfaces.push(a);return this},this.prototype=function(i){return i(r),this},this.is=function(i){for(const a of this.interfaces)if(a===i)return!0;return!1},this[Symbol.hasInstance]=function(i){return i.is(this)};function n(i){for(const a in this.properties)if(s.call(this,i,this.properties[a])===BreakSignal)break}function s(i,a){const c=a.name,d=a.types,$=a.isRequired,y=c in i.properties,g=i.properties[c],P=d.length>0,O=i.isAbstract;if($&&!y){if(O)return i.missedProperties[c]=w=>s.call(this,w,a),BreakSignal;throw new MissingPropError(this,i,a)}if(y&&P&&!allowed(g,d))throw new PropTypeMismatchError(this,i,a,g);P&&o(this,i,a)}function o(i,a,c){a.properties[Type.PROXY_PROP_PREFIX+c.name]=a.properties[c.name],Object.defineProperty(a.properties,c.name,{get:function(){return this[Type.PROXY_KEY][c.name]},set:function(d){if(!allowed(d,c.types))throw new PropAssignTypeMismatchError(i,a,c,d);this[Type.PROXY_KEY][c.name]=d}})}function h(i){for(const a in this.methods)if(p.call(this,i,this.methods[a])===BreakSignal)break}function p(i,a){const c=a.name,d=c in i.methods,$=i.isAbstract;if(!d){if($)return i.missedMethods[c]=u=>p.call(this,u,a),BreakSignal;throw new MissingMethodError(this,i,a)}const y=i.methods[c],g=getArguments(y.toString()),P=a.returnTypes;for(let u=0;u<a.arguments.length;u++){const m=a.arguments[u],f=g[u];if(m.isRequired&&f===void 0)throw new MissingArgumentError(this,i,a,m,u)}const O=i.methods[c];function w(...u){for(let f=0;f<$rule.arguments.length;f++){const l=$rule.arguments[f],T=l.isRequired,C=l.defaultValue,b=u[f];l.name,$definedArgs[f];const M=l.types,R=M.length>0;if(T&&b===void 0)if(C!==void 0)u[f]=b=C;else throw new $ArgumentTypeMismatch($iface,$type,$rule,l,f);else if(R&&!$allowed(b,M))throw new $ArgumentTypeMismatch($iface,$type,$rule,l,f,b)}const m=$proxifiedMethod.apply(this,u);if($returns.length>0&&!$allowed(m,$returns))throw new $ReturnTypeMismatch($iface,$type,$rule,m);return m}w.dependencies={$type:i,$iface:this,$returns:P,$allowed:allowed,$rule:a,$definedArgs:g,$proxifiedMethod:O,$ReturnTypeMismatch:ReturnTypeMismatch,$ArgumentTypeMismatch:ArgumentTypeMismatch},i.methods[c]=w}}function allowed(e,t){for(const r of t)if(tagName(e)==r.prototype.constructor.name)return!0;return!1}function Builder(){this.properties={},this.methods={}}Builder.prototype.property=function(e,t){return this.properties[e]=new Property(e,t)};Builder.prototype.method=function(e,t){t(this.methods[e]=new Method(e))};function Property(e,t){this.name=e,this.isRequired=!1,this.types=[],t&&this.allows(t)}Property.prototype.required=function(){return this.isRequired=!0,this};Property.prototype.allows=function(e){return this.types=tagName(e)=="Array"?e:[e],this};function Method(e){this.name=e,this.arguments=[],this.returnTypes=[]}Method.prototype.argument=function(e,t){const r=new Argument(e);return this.arguments.push(r.allows(t)),r};Method.prototype.returns=function(e){return this.returnTypes=tagName(e)=="Array"?e:e===void 0?[]:[e],this};function Argument(e){this.name=e,this.types=[],this.isRequired=!1,this.defaultValue=void 0}Argument.prototype.allows=function(e){return this.types=tagName(e)=="Array"?e:e===void 0?[]:[e],this};Argument.prototype.required=function(){return this.isRequired=!0,this};Argument.prototype.default=function(e){return this.defaultValue=e,this};function bindMagicalParentWord(e,t,r,n,s){const o=t.name+"."+r,h=t.methods[r],p={...h.dependencies,parent:(i,a)=>(tagName(i)=="Array"&&(a=i,i=void 0),parentalAccess(e,t,r,n,s,i,a))};return closured(h,p,o)}function parentalAccess(e,t,r,n,s,o,h){if((e=e.parent)===null)throw new ReferenceError("The "+t.name+" is a type that does not extend another type, the parent method cannot be used in the "+r+" method.");let p=getPrototypeOf(s);if(n===s&&(p=getPrototypeOf(p),e=e.parent),o===void 0&&(o=r),o in p)return p[o].apply(n,h);throw getPrototypeOf(p)===null?new ReferenceError('"parent" method was called illegally in '+e.parent.name+"."+r+" method. Within the parentless types, using parent method is ineffective."):new ReferenceError("The parent method used in "+t.name+"."+r+" tried to access method "+o+", which is not defined in type "+t.parent.name+"!")}function Type(name){if(!(this instanceof Type))return new Type(name);if(typeof name!="string"||/^[a-z_$]{1}[a-z0-9_$]*$/i.test(name)===!1)throw TypeError("In order to create a type, you need to provide a valid value as a string in the first parameter, which can also be a function name!");const coveredInterfaces=[],PROXY_KEY=Type.PROXY_KEY="__proxifiedProperties__",PROXY_PROP_PREFIX=Type.PROXY_PROP_PREFIX="$proxified_";this.name=name,this.parent=null,this.types=[name],this.traits=[],this.interfaces=[],this.constructor=eval("( function "+name+"(){})"),this.methods={},this.isAbstract=!1,this.missedMethods={},this.missedProperties={},this.properties={},this.abstract=function(){return this.isAbstract=!0,this},this.prototype=function(e){for(const t in e){const r=e[t];this[r instanceof Function?"methods":"properties"][t]=r}if(arguments[1]===void 0){for(const n of this.interfaces)coveredInterfaces.includes(n.name)||(coveredInterfaces.push(n.name),n.apply(this));const t=this.getInheritedMissedProperties(),r=this.getInheritedMissedMethods();for(const n in t)t[n](this);for(const n in r)r[n](this)}return this},this.extends=function(e){return this.parent=e,this.types=[...this.types,...e.types],this.traits=[...this.traits,...e.traits],this},this.implements=function(...e){return this.interfaces=e,this},this.use=function(e,t){return this.prototype(t?rename(e.properties,t,!0):e.properties,!1),this.traits=[...this.traits,...e.traits],this},this.create=function(){const e=this,t=new this.constructor,r=this.getInheritedProperties();let n;if(Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)),this.parent){let s=this;for(n=setPrototypeOf(t,{});s;){defineProp(n,"constructor",s.constructor);for(const o in s.methods)defineProp(n,o,bindMagicalParentWord(this,s,o,t,n));if(!s.parent)break;n=setPrototypeOf(n,{}),s=s.parent}}for(const s in this.methods)getPrototypeOf(t)[s]=bindMagicalParentWord(this,this,s,t,t);n=setPrototypeOf(n,{});for(const s in t)if(s.startsWith(PROXY_PROP_PREFIX)){const o=s.replace(PROXY_PROP_PREFIX,"");PROXY_KEY in n||defineProp(n,PROXY_KEY,{}),n[PROXY_KEY][o]=t[s],delete t[s]}return defineProp(n,"is",s=>e.is(s,!0)),defineProp(n,"behave",s=>e.behave(s)),defineProp(n,"constructor",Type),"construct"in t&&t.construct.call(t,...arguments),t},this.getInheritedProperties=function(){const e={};return this.parent&&Object.defineProperties(e,Object.getOwnPropertyDescriptors(this.parent.getInheritedProperties())),Object.defineProperties(e,Object.getOwnPropertyDescriptors(this.properties)),e},this.getInheritedMethods=function(){const e={};let t=this;for(;t;){for(const r in t.methods)e[r]=t.methods[r];t=t.parent}return e},this.getInheritedMissedProperties=function(){const e={};let t=this;for(;t;){for(const r in t.missedProperties)e[r]=t.missedProperties[r];t=t.parent}return e},this.getInheritedMissedMethods=function(){const e={};let t=this;for(;t;){for(const r in t.missedMethods)e[r]=t.missedMethods[r];t=t.parent}return e},this.behave=function(e){return this.traits.includes(e.name)},this.is=function(e,t){if(e instanceof Type)return this.types.includes(e.name);if(e instanceof Interface){let r=!1,n=this;e:for(;n;){for(const s of n.interfaces)if(s.is(e)){r=!0;break e}n=n.parent}return r}else if(!t){for(;e=getPrototypeOf(e);)if(Object.is(e.constructor,this.constructor))return!0}return!1},this[Symbol.hasInstance]=function(e){return e.is(this)}}function Trait(e){if(!(this instanceof Trait))return new Trait(e);this.name=e,this.traits=[this.name],this.properties={},this.use=function(t,r){return this.prototype(r?rename(t.properties,r,!0):t.properties),this.traits=[...this.traits,...t.traits],this},this.prototype=function(t){return Object.assign(this.properties,t),this},this.behave=function(t){return this.traits.includes(t.name)},this[Symbol.hasInstance]=function(t){return t.behave(this)}}
